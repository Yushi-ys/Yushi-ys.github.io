<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode第 322 场周赛</title>
      <link href="/2022/12/04/LeetCode%E7%AC%AC%20322%20%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
      <url>/2022/12/04/LeetCode%E7%AC%AC%20322%20%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h5 id="欢迎来到第-322-场周赛"><a href="#欢迎来到第-322-场周赛" class="headerlink" title="欢迎来到第 322 场周赛"></a>欢迎来到第 322 场周赛</h5><h5 id="本场竞赛由「阿里巴巴质量创新大会-TICA」赞助"><a href="#本场竞赛由「阿里巴巴质量创新大会-TICA」赞助" class="headerlink" title="本场竞赛由「阿里巴巴质量创新大会 TICA」赞助"></a>本场竞赛由「阿里巴巴质量创新大会 TICA」赞助</h5><h2 id="LeetCode-6253-回环句"><a href="#LeetCode-6253-回环句" class="headerlink" title="LeetCode.6253. 回环句"></a>LeetCode.6253. 回环句</h2><h5 id="Tips-对于字符串中只有一个单词的时候特判一下就好了，然后-Brute-Force-就好了，打卡题，由于-LC-暂不支持最新的-ES14，所以手动实现一下-Array-和-String-的-at-方法"><a href="#Tips-对于字符串中只有一个单词的时候特判一下就好了，然后-Brute-Force-就好了，打卡题，由于-LC-暂不支持最新的-ES14，所以手动实现一下-Array-和-String-的-at-方法" class="headerlink" title="Tips: 对于字符串中只有一个单词的时候特判一下就好了，然后 Brute Force 就好了，打卡题，由于 LC 暂不支持最新的 ES14，所以手动实现一下 Array 和 String 的 at 方法"></a>Tips: 对于字符串中只有一个单词的时候特判一下就好了，然后 Brute Force 就好了，打卡题，由于 LC 暂不支持最新的 ES14，所以手动实现一下 Array 和 String 的 at 方法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">sentence</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">at</span> = <span class="keyword">function</span> (<span class="params">index</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="variable language_">this</span>[<span class="variable language_">this</span>.<span class="property">length</span> + index];</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>[index];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">at</span> = <span class="keyword">function</span> (<span class="params">index</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="variable language_">this</span>[<span class="variable language_">this</span>.<span class="property">length</span> + index];</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>[index];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> isCircularSentence = <span class="keyword">function</span> (<span class="params">sentence</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> len = sentence.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">if</span> (sentence.<span class="property">length</span> === <span class="number">1</span>) <span class="keyword">return</span> sentence[<span class="number">0</span>] === sentence[len - <span class="number">1</span>];</span><br><span class="line">  sentence = sentence.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> back = sentence.<span class="title function_">at</span>(-<span class="number">1</span>).<span class="title function_">at</span>(-<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> val <span class="keyword">of</span> sentence) &#123;</span><br><span class="line">    <span class="keyword">if</span> (val[<span class="number">0</span>] === back) &#123;</span><br><span class="line">      back = val.<span class="title function_">at</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-6254-划分技能点相等的团队"><a href="#LeetCode-6254-划分技能点相等的团队" class="headerlink" title="LeetCode.6254. 划分技能点相等的团队"></a>LeetCode.6254. 划分技能点相等的团队</h2><h5 id="Tips-双指针分别首尾出发，将数组排序，若存在可全部分队的情况，每对数字和相等，则说明排序后一定是首尾递进凑对的形式（最大与最小一队，第二大与第二小一队，以此类推），所以只需要排序后，根据双指针之和是否等于首尾元素和，可以判断是否能全部分完，若中间出现和异常的-L、R-数对，说明不能完全分完，直接返回-1。判断凑对后-res-记录结果即可"><a href="#Tips-双指针分别首尾出发，将数组排序，若存在可全部分队的情况，每对数字和相等，则说明排序后一定是首尾递进凑对的形式（最大与最小一队，第二大与第二小一队，以此类推），所以只需要排序后，根据双指针之和是否等于首尾元素和，可以判断是否能全部分完，若中间出现和异常的-L、R-数对，说明不能完全分完，直接返回-1。判断凑对后-res-记录结果即可" class="headerlink" title="Tips: 双指针分别首尾出发，将数组排序，若存在可全部分队的情况，每对数字和相等，则说明排序后一定是首尾递进凑对的形式（最大与最小一队，第二大与第二小一队，以此类推），所以只需要排序后，根据双指针之和是否等于首尾元素和，可以判断是否能全部分完，若中间出现和异常的 L、R 数对，说明不能完全分完，直接返回-1。判断凑对后 res 记录结果即可"></a>Tips: 双指针分别首尾出发，将数组排序，若存在可全部分队的情况，每对数字和相等，则说明排序后一定是首尾递进凑对的形式（最大与最小一队，第二大与第二小一队，以此类推），所以只需要排序后，根据双指针之和是否等于首尾元素和，可以判断是否能全部分完，若中间出现和异常的 L、R 数对，说明不能完全分完，直接返回-1。判断凑对后 res 记录结果即可</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">skill</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">at</span> = <span class="keyword">function</span> (<span class="params">index</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="variable language_">this</span>[<span class="variable language_">this</span>.<span class="property">length</span> + index];</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>[index];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> dividePlayers = <span class="keyword">function</span> (<span class="params">skill</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  skill = skill.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">let</span> l = <span class="number">0</span>,</span><br><span class="line">    r = skill.<span class="property">length</span> - <span class="number">1</span>,</span><br><span class="line">    sk = skill[<span class="number">0</span>] + skill.<span class="title function_">at</span>(-<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (skill[l] + skill[r] == sk) &#123;</span><br><span class="line">      res += skill[l] * skill[r];</span><br><span class="line">      l++;</span><br><span class="line">      r--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-6255-两个城市间路径的最小分数"><a href="#LeetCode-6255-两个城市间路径的最小分数" class="headerlink" title="LeetCode.6255. 两个城市间路径的最小分数"></a>LeetCode.6255. 两个城市间路径的最小分数</h2><h5 id="Tips-BFS-模板题，先构建点到点的映射表，再套模板就行了…"><a href="#Tips-BFS-模板题，先构建点到点的映射表，再套模板就行了…" class="headerlink" title="Tips: BFS 模板题，先构建点到点的映射表，再套模板就行了…"></a>Tips: BFS 模板题，先构建点到点的映射表，再套模板就行了…</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 索引为出发点u, map的key为目的点v, map的value为花费w</span></span><br><span class="line">[</span><br><span class="line">    <span class="title class_">Map</span>(<span class="number">0</span>) &#123;&#125;,</span><br><span class="line">    <span class="title class_">Map</span>(<span class="number">2</span>) &#123; <span class="number">2</span> =&gt; <span class="number">9</span>, <span class="number">4</span> =&gt; <span class="number">7</span> &#125;,</span><br><span class="line">    <span class="title class_">Map</span>(<span class="number">3</span>) &#123; <span class="number">1</span> =&gt; <span class="number">9</span>, <span class="number">3</span> =&gt; <span class="number">6</span>, <span class="number">4</span> =&gt; <span class="number">5</span> &#125;,</span><br><span class="line">    <span class="title class_">Map</span>(<span class="number">1</span>) &#123; <span class="number">2</span> =&gt; <span class="number">6</span> &#125;,</span><br><span class="line">    <span class="title class_">Map</span>(<span class="number">2</span>) &#123; <span class="number">2</span> =&gt; <span class="number">5</span>, <span class="number">1</span> =&gt; <span class="number">7</span> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[][]</span>&#125; <span class="variable">roads</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minScore = <span class="keyword">function</span> (<span class="params">n, roads</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> graph = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: n + <span class="number">1</span> &#125;, <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Map</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [u, v, w] <span class="keyword">of</span> roads) &#123;</span><br><span class="line">    graph[u].<span class="title function_">set</span>(v, w);</span><br><span class="line">    graph[v].<span class="title function_">set</span>(u, w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> queue = [<span class="number">1</span>, n];</span><br><span class="line">  <span class="keyword">const</span> vis = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="literal">false</span>);</span><br><span class="line">  vis[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">  vis[n] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">let</span> ans = <span class="title class_">Infinity</span>;</span><br><span class="line">  <span class="keyword">while</span> (queue.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> next = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> u <span class="keyword">of</span> queue) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> [v, w] <span class="keyword">of</span> graph[u]) &#123;</span><br><span class="line">        ans = <span class="title class_">Math</span>.<span class="title function_">min</span>(ans, w);</span><br><span class="line">        <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">          next.<span class="title function_">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        vis[v] = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    queue = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-6256-将节点分成尽可能多的组"><a href="#LeetCode-6256-将节点分成尽可能多的组" class="headerlink" title="LeetCode.6256. 将节点分成尽可能多的组"></a>LeetCode.6256. 将节点分成尽可能多的组</h2><h5 id="Tips-还是-BFS-题，首先以每个顶点为起点，使用广度优先搜索，求出最大值。然后由于题目中给出可能存在多个联通块，所以需要保存每个联通块然后求和。用一波熟悉的-C"><a href="#Tips-还是-BFS-题，首先以每个顶点为起点，使用广度优先搜索，求出最大值。然后由于题目中给出可能存在多个联通块，所以需要保存每个联通块然后求和。用一波熟悉的-C" class="headerlink" title="Tips: 还是 BFS 题，首先以每个顶点为起点，使用广度优先搜索，求出最大值。然后由于题目中给出可能存在多个联通块，所以需要保存每个联通块然后求和。用一波熟悉的 C++"></a>Tips: 还是 BFS 题，首先以每个顶点为起点，使用广度优先搜索，求出最大值。然后由于题目中给出可能存在多个联通块，所以需要保存每个联通块然后求和。用一波熟悉的 C++</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">magnificentSets</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每个顶点到各个顶点的距离</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">e</span>(n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : edges) &#123;</span><br><span class="line">            e[edge[<span class="number">0</span>]].<span class="built_in">push_back</span>(edge[<span class="number">1</span>]);</span><br><span class="line">            e[edge[<span class="number">1</span>]].<span class="built_in">push_back</span>(edge[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp; <span class="comment">// key用联通块中最小的顶点，value为该联通块最大距离</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从每个顶点遍历，并以最小顶点保存当前联通块的最大距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">            dis[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> mn = n;</span><br><span class="line">            <span class="type">int</span> mx = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                mn = <span class="built_in">min</span>(x, mn);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> d : e[x]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dis[d] == <span class="number">0</span>) &#123;</span><br><span class="line">                        dis[d] = dis[x] + <span class="number">1</span>;</span><br><span class="line">                        mx = <span class="built_in">max</span>(mx, dis[d]);</span><br><span class="line">                        q.<span class="built_in">push</span>(d);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">abs</span>(dis[d] - dis[x]) != <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mp[mn] = <span class="built_in">max</span>(mp[mn], mx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所有联通块求和</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : mp) &#123;</span><br><span class="line">            ans += p.second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>memo useCallback useMemo 解决了什么问题</title>
      <link href="/2022/12/03/memo%E3%80%81useCallback%E5%92%8CuseMemo%20%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/"/>
      <url>/2022/12/03/memo%E3%80%81useCallback%E5%92%8CuseMemo%20%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>最近在公司里写代码的时候看见了 <strong>useMemo</strong> 这个 hooks，由于被裁员之后的摆烂(一个月) + 下班回家高强度 <del>LOL</del> 和 <del>Csgo</del>，我差点忘了这个 hooks 的用途，今天来复习一下</p><h2 id="React-memo"><a href="#React-memo" class="headerlink" title="React.memo()"></a>React.memo()</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>React 中当组件的 props 或 state 变化时，会重新渲染视图，实际开发会遇到不必要的渲染场景。看个例子：</p><p>子组件：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ChildComp</span>: <span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;子组件render&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>====子组件===<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">ChildComp</span>;</span><br></pre></td></tr></table></figure><p>父组件:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ChildComp</span> <span class="keyword">from</span> <span class="string">&quot;./components/child&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App</span>: <span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;increment&#125;</span>&gt;</span>点击次数：&#123;count&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ChildComp</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>当我们点击父组件的按钮时，会触发父组件的 setState 从而导致父组件重新渲染，但此时子组件并没有任何变化，但是依然能在控制台中看到子组件被重新渲染的信息</p><p><img src="https://s2.loli.net/2022/12/03/pfJL8HMTk6ys7de.jpg" alt="为加memo时，子组件被重新渲染.jpg"></p><p><font color="red" size="3">我们期待的结果：子组件的 props 和 state 没有变化时，即便父组件渲染，也不要渲染子组件。</font></p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p><strong>修改子组件，用 React.memo() 包一层</strong>。</p><p>这种写法是 React 的高阶组件写法，将组件作为函数(memo)的参数，函数的返回值(ChildComp)是一个新的组件。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; memo &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">memo</span>(<span class="title class_">ChildComp</span>);</span><br></pre></td></tr></table></figure><h2 id="React-useCallback"><a href="#React-useCallback" class="headerlink" title="React.useCallback()"></a>React.useCallback()</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>上面的例子中，父组件只是简单调用子组件，并未给子组件传递任何属性。<br>当一个父组件给子组件传递属性时：</p><p>子组件：（子组件仍然用 React.memo() 包裹一层）</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; memo &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IProps</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">onClick</span>: <span class="function">(<span class="params">val: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ChildComp</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">IProps</span>&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; name, onClick &#125; = props;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`子组件render, 这是传递过来的参数：<span class="subst">$&#123;name&#125;</span> `</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      ====子组件===</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> onClick(&quot;hello&quot;)&#125;&gt;改变 name 值<span class="tag">&lt;/<span class="name">button</span>&gt;</span>;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">memo</span>(<span class="title class_">ChildComp</span>);</span><br></pre></td></tr></table></figure><p>父组件：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ChildComp</span> <span class="keyword">from</span> <span class="string">&quot;./components/child&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App</span>: <span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [name, setName] = <span class="title function_">useState</span>(<span class="string">&quot;hi~&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">changeName</span> = (<span class="params">newName: <span class="built_in">string</span></span>) =&gt; <span class="title function_">setName</span>(newName);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;increment&#125;</span>&gt;</span>点击次数：&#123;count&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ChildComp</span> <span class="attr">name</span>=<span class="string">&#123;name&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;changeName&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>当我们点击父组件的按钮时，我们仍然可以看到子组件再不停的渲染</p><p><img src="https://s2.loli.net/2022/12/03/3H5wlRNvaTxPnd8.jpg" alt="QQ截图20221203222017.jpg"></p><h3 id="分析下原因"><a href="#分析下原因" class="headerlink" title="分析下原因"></a>分析下原因</h3><ul><li>我们点击父组件按钮，改变了父组件中 count 变量值（父组件的 state 值），进而导致父组件重新渲染</li><li>父组件重新渲染时，会重新创建 changeName 函数，即传给子组件的 onClick 属性发生了变化，导致子组件渲染</li></ul><p>所以还是由于子组件的 props 改变了，导致子组件渲染了</p><p>（可我们只是点击了父组件的按钮，并未对子组件做任何操作，压根就不希望子组件的 props 有变化……）</p><h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><p><strong>修改父组件的 changeName 方法，用 useCallback 钩子函数包裹一层</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useCallback &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> changeName = <span class="title function_">useCallback</span>(<span class="function">(<span class="params">newName: <span class="built_in">string</span></span>) =&gt;</span> <span class="title function_">setName</span>(newName), []);</span><br></pre></td></tr></table></figure><p>原因：useCallback() 起到了缓存的作用，即便父组件渲染了，useCallback() 包裹的函数也不会重新生成，会返回上一次的函数引用</p><h2 id="React-useMemo"><a href="#React-useMemo" class="headerlink" title="React.useMemo()"></a>React.useMemo()</h2><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><p>前面父组件调用子组件时传递的 name 属性是个字符串，如果换成传递对象会怎样?????</p><p>父组件</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useCallback, useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ChildComp</span> <span class="keyword">from</span> <span class="string">&quot;./components/child&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App</span>: <span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [name, setName] = <span class="title function_">useState</span>(<span class="string">&quot;hi~&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> [age] = <span class="title function_">useState</span>(<span class="number">20</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> changeName = <span class="title function_">useCallback</span>(<span class="function">(<span class="params">newName: <span class="built_in">string</span></span>) =&gt;</span> <span class="title function_">setName</span>(newName), []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> info = &#123; name, age &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;increment&#125;</span>&gt;</span>点击次数：&#123;count&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ChildComp</span> <span class="attr">info</span>=<span class="string">&#123;info&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;changeName&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>子组件</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; memo &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IInfo</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IProps</span> &#123;</span><br><span class="line">  <span class="attr">info</span>: <span class="title class_">IInfo</span>;</span><br><span class="line">  <span class="attr">onClick</span>: <span class="function">(<span class="params">val: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ChildComp</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">IProps</span>&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; info, onClick &#125; = props;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`子组件render, 这是传递过来的参数：<span class="subst">$&#123;info.name&#125;</span>  <span class="subst">$&#123;info.age&#125;</span> `</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      ====子组件===</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> onClick(&quot;hello&quot;)&#125;&gt;改变 name 值<span class="tag">&lt;/<span class="name">button</span>&gt;</span>;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">memo</span>(<span class="title class_">ChildComp</span>);</span><br></pre></td></tr></table></figure><p>当我们点击父组件的按钮时，我们仍然可以看到子组件再不停的渲染</p><p><img src="https://s2.loli.net/2022/12/03/Qb45AThBmP3lEIr.jpg" alt="QQ截图20221203223252.jpg"></p><p>分析原因跟调用函数是一样的：</p><ul><li>点击父组件按钮，触发父组件重新渲染；</li><li>父组件渲染，const info = { name, age } 一行会重新生成一个新对象(地址不一样)，导致传递给子组件的 info 属性值变化，进而导致子组件重新渲染。</li></ul><h3 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h3><p>使用 useMemo 对对象属性包一层<br>useMemo 有两个参数：</p><ul><li>第一个参数是个函数，返回的对象指向同一个引用，不会创建新对象；</li><li>第二个参数是个数组，只有数组中的变量改变时，第一个参数的函数才会返回一个新的对象。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useMemo &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> info = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> (&#123; name, age &#125;), [name, age]);</span><br></pre></td></tr></table></figure><p>再次点击父组件按钮，控制台中不再打印子组件被渲染的信息了</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>屏蔽不想搜索到结果的来源</title>
      <link href="/2022/12/01/%E5%B1%8F%E8%94%BD%E4%B8%8D%E6%83%B3%E6%90%9C%E7%B4%A2%E5%88%B0%E7%BB%93%E6%9E%9C%E7%9A%84%E6%9D%A5%E6%BA%90/"/>
      <url>/2022/12/01/%E5%B1%8F%E8%94%BD%E4%B8%8D%E6%83%B3%E6%90%9C%E7%B4%A2%E5%88%B0%E7%BB%93%E6%9E%9C%E7%9A%84%E6%9D%A5%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h2 id="正常情况下搜索是这样的"><a href="#正常情况下搜索是这样的" class="headerlink" title="正常情况下搜索是这样的"></a>正常情况下搜索是这样的</h2><p><img src="https://s2.loli.net/2022/12/01/hKt2EJ7SYOaAILe.jpg" alt="未加 -csdn 之前.jpg"></p><font size="3">看到了熟悉的 CSDN、慕课(广告)、简书之类的搜索结果，但这并不是我们想要的，因为有的论坛推荐的答案很不靠谱，所以我们可以在搜索的内容后加上 -"我们不想获得结果的来源" 即可屏蔽掉，如下：<font><p><img src="https://s2.loli.net/2022/12/01/1CjLnBe7EpuJylv.jpg" alt="加上 -csdn 之后.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
