<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>剑指offer专题</title>
      <link href="/2023/01/09/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A2%98/"/>
      <url>/2023/01/09/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><font size="18">💘 长期更新</font></p><h2 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/?envType=study-plan&id=lcof&plan=lcof&plan_progress=c8ciafv">剑指 Offer 09. 用两个栈实现队列</a></h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据题目所言，可以使用双栈写法，将一个栈当作输入栈，用于压入 appendTail 传入的数据；另一个栈当作输出栈，用于 deleteHead 操作。每次我们 deleteHead 时，如果输出栈为空，则将输入栈的数据全部依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">CQueue</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">inStack</span> = [];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">outStack</span> = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">value</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">CQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">appendTail</span> = <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">inStack</span>.<span class="title function_">push</span>(value);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">CQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">deleteHead</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">outStack</span>.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">inStack</span>.<span class="property">length</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">in2out</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">outStack</span>.<span class="title function_">pop</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">CQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">in2out</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">inStack</span>.<span class="property">length</span>) <span class="variable language_">this</span>.<span class="property">outStack</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">inStack</span>.<span class="title function_">pop</span>());</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new CQueue()</span></span><br><span class="line"><span class="comment"> * obj.appendTail(value)</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.deleteHead()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-30-包含-min-函数的栈"><a href="#剑指-Offer-30-包含-min-函数的栈" class="headerlink" title="剑指 Offer 30. 包含 min 函数的栈"></a><a href="https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/?envType=study-plan&id=lcof&plan=lcof&plan_progress=c8ciafv">剑指 Offer 30. 包含 min 函数的栈</a></h2><h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><p><strong>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</strong></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>首先根据栈的特性，我们可以推断出一个结论，如果一个元素 a 在入栈时，栈里面已经有了 b，c，d 元素，那么无论我们怎么操作，只要 a 还在栈当中，那么 b，c，d 就一定也在栈中，所以在 a 被弹出之前，b，c，d 必定不会被弹出。</p><p>因此我们可以使用一个辅助栈，把每个元素 a 入栈时把当前栈当中的最小值 minn 存起来。在这之后无论何时，如果栈顶元素是 a，我们就可以直接返回这个 a 对应存储的最小值 minn</p><ul><li><p>当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中；</p></li><li><p>当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出；</p></li><li><p>在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中</p></li></ul><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * initialize your data structure here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">MinStack</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">stack</span> = [];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">min_stack</span> = [<span class="title class_">Infinity</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">x</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="title function_">push</span>(x);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">min_stack</span>.<span class="title function_">push</span>(<span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="variable language_">this</span>.<span class="property">min_stack</span>.<span class="title function_">at</span>(-<span class="number">1</span>), x));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="title function_">pop</span>();</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">min_stack</span>.<span class="title function_">pop</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">top</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="title function_">at</span>(-<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">min</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">min_stack</span>.<span class="title function_">at</span>(-<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MinStack()</span></span><br><span class="line"><span class="comment"> * obj.push(x)</span></span><br><span class="line"><span class="comment"> * obj.pop()</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.top()</span></span><br><span class="line"><span class="comment"> * var param_4 = obj.min()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a><a href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/?envType=study-plan&id=lcof&plan=lcof&plan_progress=c8ciafv">剑指 Offer 06. 从尾到头打印链表</a></h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>由于题目说用数组返回，那么直接顺序遍历依次存入数组，最后返回数组的倒序即可</p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reversePrint = <span class="keyword">function</span> (<span class="params">head</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> curr = head;</span><br><span class="line">  <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    res.<span class="title function_">push</span>(curr.<span class="property">val</span>);</span><br><span class="line">    curr = curr.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.<span class="title function_">reverse</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a><a href="https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/?envType=study-plan&id=lcof&plan=lcof&plan_progress=c8ciafv">剑指 Offer 24. 反转链表</a></h2><h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>这是一道非常经典的题目，大四春招的时候，CVTE 一面二面都是这个题目，一面迭代，二面递归(太紧张没写出来)。</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>在遍历链表时，将当前节点的 next 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用</p><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span> (<span class="params">head</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> prev = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> curr = head;</span><br><span class="line">  <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    <span class="keyword">const</span> next = curr.<span class="property">next</span>;</span><br><span class="line">    curr.<span class="property">next</span> = prev;</span><br><span class="line">    prev = curr;</span><br><span class="line">    curr = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-35-复杂链表的复制"><a href="#剑指-Offer-35-复杂链表的复制" class="headerlink" title="剑指 Offer 35. 复杂链表的复制"></a><a href="https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/?envType=study-plan&id=lcof&plan=lcof&plan_progress=c8ciafv">剑指 Offer 35. 复杂链表的复制</a></h2><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>如果是普通链表，我们可以直接按照遍历的顺序创建链表节点。但是这题特殊在每个节点包含一个 random 指针指向链表中的任意节点或者 null，所以如果直接遍历拷贝的话，在拷贝过程中，当前节点的 random 指针指向的节点可能还没被创建，所以不能这样。所以可以采用哈希表来存储[旧节点, 新节点]，第一遍存，第二遍拷贝</p><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // Definition for a Node.</span></span><br><span class="line"><span class="comment"> * function Node(val, next, random) &#123;</span></span><br><span class="line"><span class="comment"> *    this.val = val;</span></span><br><span class="line"><span class="comment"> *    this.next = next;</span></span><br><span class="line"><span class="comment"> *    this.random = random;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Node</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Node</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> copyRandomList = <span class="keyword">function</span> (<span class="params">head</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> curr = head;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">  <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    map.<span class="title function_">set</span>(curr, <span class="keyword">new</span> <span class="title class_">Node</span>(curr.<span class="property">val</span>));</span><br><span class="line">    curr = curr.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  curr = head;</span><br><span class="line">  <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    map.<span class="title function_">get</span>(curr).<span class="property">next</span> = map.<span class="title function_">get</span>(curr.<span class="property">next</span>) || <span class="literal">null</span>;</span><br><span class="line">    map.<span class="title function_">get</span>(curr).<span class="property">random</span> = map.<span class="title function_">get</span>(curr.<span class="property">random</span>) || <span class="literal">null</span>;</span><br><span class="line">    curr = curr.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> map.<span class="title function_">get</span>(head);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记LeetCode中一次位运算踩坑问题</title>
      <link href="/2023/01/08/%E8%AE%B0LeetCode%E4%B8%AD%E4%B8%80%E6%AC%A1%E4%BD%8D%E8%BF%90%E7%AE%97%E8%B8%A9%E5%9D%91%E9%97%AE%E9%A2%98/"/>
      <url>/2023/01/08/%E8%AE%B0LeetCode%E4%B8%AD%E4%B8%80%E6%AC%A1%E4%BD%8D%E8%BF%90%E7%AE%97%E8%B8%A9%E5%9D%91%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>原题在这：<br><a href="https://leetcode.cn/problems/count-number-of-homogenous-substrings/description/">https://leetcode.cn/problems/count-number-of-homogenous-substrings/description/</a></p><p>直接贴代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getNums</span> = (<span class="params">n</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> ((n + <span class="number">1</span>) * n) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> countHomogenous = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="variable constant_">MOD</span> = <span class="number">1000000007</span>;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>,</span><br><span class="line">    right = <span class="number">0</span>,</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> len = s.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">while</span> (right &lt; len) &#123;</span><br><span class="line">    <span class="keyword">const</span> left_word = s[left];</span><br><span class="line">    <span class="keyword">while</span> (right &lt; len &amp;&amp; s[right] === left_word) &#123;</span><br><span class="line">      right++;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = (cnt + <span class="title function_">getNums</span>(right - left)) % <span class="variable constant_">MOD</span>;</span><br><span class="line">    left = right;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路很简单，对于某个连续字串 aaaa 来说，同构字符串 a 出现 4 次，aa 出现 3 次，aaa 出现 2 次，aaaa 出现 1 次。可以看出对于长度为 n 的相同字母的连续字串，同构字符串的出现次数为 1 + 2 + … + n, 即(n + 1) * n / 2。我们从前往后遍历字符串的每一个字符，统计相同连续字母的子串长度，每次累加长度即可</p><p>但是提交后却发现</p><p><img src="https://s2.loli.net/2023/01/08/KdrusIMm5wEiz6n.jpg" alt="LC-1759提交答案错误.jpg"></p><p>我锁定问题出在 getNum 函数，这里我习惯性的使用了位运算去求(n + 1) * n 除以 2 的结果，打印了下长度，我发现形参 n 的长度为 100000，也就是 1e5，很显然，(1e5 + 1) * 1e5 约等于 <font color="red">1e10</font></p><p>然后我看到了这篇文章：<a href="https://www.jianshu.com/p/49979d935716">https://www.jianshu.com/p/49979d935716</a></p><p>得到以下结论：在 JavaScript 内部，数值都是以 64 位浮点数的形式储存，<font color="red">但是做位运算的时候，是以 32 位带符号的整数进行运算的，并且返回值也是一个 32 位带符号的整数。</font>而 32 位整数数值范围从-2147483648 到 2147483647，很显然 1e10 不在这个范围，所以位运算就会出错…</p><p>(把那里换成 /2 就好了)</p>]]></content>
      
      
      <categories>
          
          <category> 小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust-rand踩坑</title>
      <link href="/2022/12/16/Rust-rand%E8%B8%A9%E5%9D%91/"/>
      <url>/2022/12/16/Rust-rand%E8%B8%A9%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>今天写随机函数的时候遇到的问题，一直报错，去了官网看，没找到具体的用法解释</p><p>后来发现是版本的问题</p><p><strong>rand 从 0.7 版本到 0.8 版本修动了 gen_range<br>用 gen_range(a…b) 替换了 gen_range(a, b)</strong></p><p><img src="https://s2.loli.net/2022/12/16/ZxfFJvCRuLmkASi.jpg" alt="rust-rand逗号间隔.jpg"><br>换成如下写法就没有问题了</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">target</span> = rand::<span class="title function_ invoke__">thread_rng</span>().<span class="title function_ invoke__">gen_range</span>(<span class="number">1</span>..<span class="number">101</span>);</span><br></pre></td></tr></table></figure><p><strong>~~~当然了你也可以换成低版本~~~</strong></p>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust踩坑日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冬日有感</title>
      <link href="/2022/12/14/%E5%86%AC%E6%97%A5%E6%9C%89%E6%84%9F/"/>
      <url>/2022/12/14/%E5%86%AC%E6%97%A5%E6%9C%89%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<p><font size='4'>愿为期三年的凛冬早早过去</font><br><font size='4'>愿平安度过春日前的最后一个黑暗夜晚。</font><br><font size='4'>再愿山冈开满花，春风吹万里。</font></p><p><img src="https://s2.loli.net/2022/12/14/oYGrlLTDcxENZQK.jpg" alt="冬日有感.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随便写写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性筛(欧拉筛)</title>
      <link href="/2022/12/05/%E7%BA%BF%E6%80%A7%E7%AD%9B/"/>
      <url>/2022/12/05/%E7%BA%BF%E6%80%A7%E7%AD%9B/</url>
      
        <content type="html"><![CDATA[<p><strong>~~~想着更新勤快一点。所以，把自己很久以前写的一篇文章搬过来了 =.=，刚学算法的时候写的，凑合看吧~~~</strong></p><p>原文链接在旧博客： <a href="http://taotaozi.ronghanbing.com/blog/4">http://taotaozi.ronghanbing.com/blog/4</a></p><p><font color="red">旧博客地址，不更新了</font></p><h2 id="什么是线性筛"><a href="#什么是线性筛" class="headerlink" title="什么是线性筛"></a>什么是线性筛</h2><p>对于求多个质数时与其一个个判断不如用排除法，用空间换取大量时间</p><p>原理：筛去一定范围内的所有合数</p><p>众所周知，如果一个数是合数，那么它的倍数也一定是合数，利用这个结论，我们可以避免很多次不必要的检测。我们从小到大考虑每个数，然后同时把当前这个数的所有（比自己大的）倍数记为合数，那么运行结束的时候没有被标记的数就是素数了</p><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><p>合数可以分解成质数相乘，所以用质数相乘筛一遍，枚举质数并且一路用 i 乘过去，标记一轮</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getPrimes</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i] == <span class="literal">false</span>)&#123;</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; primes[j] * i &lt;= x; j++)&#123;</span><br><span class="line">            vis[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 JS 的 console.time 看对比一下和暴力算法的时间</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> N = <span class="number">100000000</span>;</span><br><span class="line"><span class="keyword">const</span> primes = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getPrimes</span> = (<span class="params">x</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> vis = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10000000</span>).<span class="title function_">fill</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= x; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; primes[j] * i &lt;= x; j++) &#123;</span><br><span class="line">            vis[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> primes;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&quot;Time&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> ans = <span class="title function_">getPrimes</span>(<span class="number">1000000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ans);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&quot;Time&quot;</span>); <span class="comment">//Time: 108.794921875 ms</span></span><br></pre></td></tr></table></figure><p>试了很多次，保持在 100ms 左右</p><p>暴力算法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> primes = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getPrimes</span> = (<span class="params">n</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i * i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&quot;Time&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">getPrimes</span>(i) == <span class="literal">true</span>) &#123;</span><br><span class="line">        primes.<span class="title function_">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(primes);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&quot;Time&quot;</span>);<span class="comment">//Time: 239.1748046875 ms</span></span><br></pre></td></tr></table></figure><p>平均下来 300ms 左右，是线性筛法的三倍时间</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode第 322 场周赛</title>
      <link href="/2022/12/04/LeetCode%E7%AC%AC%20322%20%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
      <url>/2022/12/04/LeetCode%E7%AC%AC%20322%20%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h5 id="欢迎来到第-322-场周赛"><a href="#欢迎来到第-322-场周赛" class="headerlink" title="欢迎来到第 322 场周赛"></a>欢迎来到第 322 场周赛</h5><h5 id="本场竞赛由「阿里巴巴质量创新大会-TICA」赞助"><a href="#本场竞赛由「阿里巴巴质量创新大会-TICA」赞助" class="headerlink" title="本场竞赛由「阿里巴巴质量创新大会 TICA」赞助"></a>本场竞赛由「阿里巴巴质量创新大会 TICA」赞助</h5><h2 id="LeetCode-6253-回环句"><a href="#LeetCode-6253-回环句" class="headerlink" title="LeetCode.6253. 回环句"></a>LeetCode.6253. 回环句</h2><h5 id="Tips-对于字符串中只有一个单词的时候特判一下就好了，然后-Brute-Force-就好了，打卡题，由于-LC-暂不支持最新的-ES14，所以手动实现一下-Array-和-String-的-at-方法"><a href="#Tips-对于字符串中只有一个单词的时候特判一下就好了，然后-Brute-Force-就好了，打卡题，由于-LC-暂不支持最新的-ES14，所以手动实现一下-Array-和-String-的-at-方法" class="headerlink" title="Tips: 对于字符串中只有一个单词的时候特判一下就好了，然后 Brute Force 就好了，打卡题，由于 LC 暂不支持最新的 ES14，所以手动实现一下 Array 和 String 的 at 方法"></a>Tips: 对于字符串中只有一个单词的时候特判一下就好了，然后 Brute Force 就好了，打卡题，由于 LC 暂不支持最新的 ES14，所以手动实现一下 Array 和 String 的 at 方法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">sentence</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">at</span> = <span class="keyword">function</span> (<span class="params">index</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="variable language_">this</span>[<span class="variable language_">this</span>.<span class="property">length</span> + index];</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>[index];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">at</span> = <span class="keyword">function</span> (<span class="params">index</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="variable language_">this</span>[<span class="variable language_">this</span>.<span class="property">length</span> + index];</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>[index];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> isCircularSentence = <span class="keyword">function</span> (<span class="params">sentence</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> len = sentence.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">if</span> (sentence.<span class="property">length</span> === <span class="number">1</span>) <span class="keyword">return</span> sentence[<span class="number">0</span>] === sentence[len - <span class="number">1</span>];</span><br><span class="line">  sentence = sentence.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> back = sentence.<span class="title function_">at</span>(-<span class="number">1</span>).<span class="title function_">at</span>(-<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> val <span class="keyword">of</span> sentence) &#123;</span><br><span class="line">    <span class="keyword">if</span> (val[<span class="number">0</span>] === back) &#123;</span><br><span class="line">      back = val.<span class="title function_">at</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-6254-划分技能点相等的团队"><a href="#LeetCode-6254-划分技能点相等的团队" class="headerlink" title="LeetCode.6254. 划分技能点相等的团队"></a>LeetCode.6254. 划分技能点相等的团队</h2><h5 id="Tips-双指针分别首尾出发，将数组排序，若存在可全部分队的情况，每对数字和相等，则说明排序后一定是首尾递进凑对的形式（最大与最小一队，第二大与第二小一队，以此类推），所以只需要排序后，根据双指针之和是否等于首尾元素和，可以判断是否能全部分完，若中间出现和异常的-L、R-数对，说明不能完全分完，直接返回-1。判断凑对后-res-记录结果即可"><a href="#Tips-双指针分别首尾出发，将数组排序，若存在可全部分队的情况，每对数字和相等，则说明排序后一定是首尾递进凑对的形式（最大与最小一队，第二大与第二小一队，以此类推），所以只需要排序后，根据双指针之和是否等于首尾元素和，可以判断是否能全部分完，若中间出现和异常的-L、R-数对，说明不能完全分完，直接返回-1。判断凑对后-res-记录结果即可" class="headerlink" title="Tips: 双指针分别首尾出发，将数组排序，若存在可全部分队的情况，每对数字和相等，则说明排序后一定是首尾递进凑对的形式（最大与最小一队，第二大与第二小一队，以此类推），所以只需要排序后，根据双指针之和是否等于首尾元素和，可以判断是否能全部分完，若中间出现和异常的 L、R 数对，说明不能完全分完，直接返回-1。判断凑对后 res 记录结果即可"></a>Tips: 双指针分别首尾出发，将数组排序，若存在可全部分队的情况，每对数字和相等，则说明排序后一定是首尾递进凑对的形式（最大与最小一队，第二大与第二小一队，以此类推），所以只需要排序后，根据双指针之和是否等于首尾元素和，可以判断是否能全部分完，若中间出现和异常的 L、R 数对，说明不能完全分完，直接返回-1。判断凑对后 res 记录结果即可</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">skill</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">at</span> = <span class="keyword">function</span> (<span class="params">index</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="variable language_">this</span>[<span class="variable language_">this</span>.<span class="property">length</span> + index];</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>[index];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> dividePlayers = <span class="keyword">function</span> (<span class="params">skill</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  skill = skill.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">let</span> l = <span class="number">0</span>,</span><br><span class="line">    r = skill.<span class="property">length</span> - <span class="number">1</span>,</span><br><span class="line">    sk = skill[<span class="number">0</span>] + skill.<span class="title function_">at</span>(-<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (skill[l] + skill[r] == sk) &#123;</span><br><span class="line">      res += skill[l] * skill[r];</span><br><span class="line">      l++;</span><br><span class="line">      r--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-6255-两个城市间路径的最小分数"><a href="#LeetCode-6255-两个城市间路径的最小分数" class="headerlink" title="LeetCode.6255. 两个城市间路径的最小分数"></a>LeetCode.6255. 两个城市间路径的最小分数</h2><h5 id="Tips-BFS-模板题，先构建点到点的映射表，再套模板就行了…"><a href="#Tips-BFS-模板题，先构建点到点的映射表，再套模板就行了…" class="headerlink" title="Tips: BFS 模板题，先构建点到点的映射表，再套模板就行了…"></a>Tips: BFS 模板题，先构建点到点的映射表，再套模板就行了…</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 索引为出发点u, map的key为目的点v, map的value为花费w</span></span><br><span class="line">[</span><br><span class="line">    <span class="title class_">Map</span>(<span class="number">0</span>) &#123;&#125;,</span><br><span class="line">    <span class="title class_">Map</span>(<span class="number">2</span>) &#123; <span class="number">2</span> =&gt; <span class="number">9</span>, <span class="number">4</span> =&gt; <span class="number">7</span> &#125;,</span><br><span class="line">    <span class="title class_">Map</span>(<span class="number">3</span>) &#123; <span class="number">1</span> =&gt; <span class="number">9</span>, <span class="number">3</span> =&gt; <span class="number">6</span>, <span class="number">4</span> =&gt; <span class="number">5</span> &#125;,</span><br><span class="line">    <span class="title class_">Map</span>(<span class="number">1</span>) &#123; <span class="number">2</span> =&gt; <span class="number">6</span> &#125;,</span><br><span class="line">    <span class="title class_">Map</span>(<span class="number">2</span>) &#123; <span class="number">2</span> =&gt; <span class="number">5</span>, <span class="number">1</span> =&gt; <span class="number">7</span> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[][]</span>&#125; <span class="variable">roads</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minScore = <span class="keyword">function</span> (<span class="params">n, roads</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> graph = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: n + <span class="number">1</span> &#125;, <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Map</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [u, v, w] <span class="keyword">of</span> roads) &#123;</span><br><span class="line">    graph[u].<span class="title function_">set</span>(v, w);</span><br><span class="line">    graph[v].<span class="title function_">set</span>(u, w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> queue = [<span class="number">1</span>, n];</span><br><span class="line">  <span class="keyword">const</span> vis = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="literal">false</span>);</span><br><span class="line">  vis[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">  vis[n] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">let</span> ans = <span class="title class_">Infinity</span>;</span><br><span class="line">  <span class="keyword">while</span> (queue.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> next = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> u <span class="keyword">of</span> queue) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> [v, w] <span class="keyword">of</span> graph[u]) &#123;</span><br><span class="line">        ans = <span class="title class_">Math</span>.<span class="title function_">min</span>(ans, w);</span><br><span class="line">        <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">          next.<span class="title function_">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        vis[v] = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    queue = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-6256-将节点分成尽可能多的组"><a href="#LeetCode-6256-将节点分成尽可能多的组" class="headerlink" title="LeetCode.6256. 将节点分成尽可能多的组"></a>LeetCode.6256. 将节点分成尽可能多的组</h2><h5 id="Tips-还是-BFS-题，首先以每个顶点为起点，使用广度优先搜索，求出最大值。然后由于题目中给出可能存在多个联通块，所以需要保存每个联通块然后求和。用一波熟悉的-C"><a href="#Tips-还是-BFS-题，首先以每个顶点为起点，使用广度优先搜索，求出最大值。然后由于题目中给出可能存在多个联通块，所以需要保存每个联通块然后求和。用一波熟悉的-C" class="headerlink" title="Tips: 还是 BFS 题，首先以每个顶点为起点，使用广度优先搜索，求出最大值。然后由于题目中给出可能存在多个联通块，所以需要保存每个联通块然后求和。用一波熟悉的 C++"></a>Tips: 还是 BFS 题，首先以每个顶点为起点，使用广度优先搜索，求出最大值。然后由于题目中给出可能存在多个联通块，所以需要保存每个联通块然后求和。用一波熟悉的 C++</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">magnificentSets</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每个顶点到各个顶点的距离</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">e</span>(n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : edges) &#123;</span><br><span class="line">            e[edge[<span class="number">0</span>]].<span class="built_in">push_back</span>(edge[<span class="number">1</span>]);</span><br><span class="line">            e[edge[<span class="number">1</span>]].<span class="built_in">push_back</span>(edge[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp; <span class="comment">// key用联通块中最小的顶点，value为该联通块最大距离</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从每个顶点遍历，并以最小顶点保存当前联通块的最大距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">            dis[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> mn = n;</span><br><span class="line">            <span class="type">int</span> mx = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                mn = <span class="built_in">min</span>(x, mn);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> d : e[x]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dis[d] == <span class="number">0</span>) &#123;</span><br><span class="line">                        dis[d] = dis[x] + <span class="number">1</span>;</span><br><span class="line">                        mx = <span class="built_in">max</span>(mx, dis[d]);</span><br><span class="line">                        q.<span class="built_in">push</span>(d);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">abs</span>(dis[d] - dis[x]) != <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mp[mn] = <span class="built_in">max</span>(mp[mn], mx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所有联通块求和</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : mp) &#123;</span><br><span class="line">            ans += p.second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>memo useCallback useMemo 解决了什么问题</title>
      <link href="/2022/12/03/memo%E3%80%81useCallback%E5%92%8CuseMemo%20%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/"/>
      <url>/2022/12/03/memo%E3%80%81useCallback%E5%92%8CuseMemo%20%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>最近在公司里写代码的时候看见了 <strong>useMemo</strong> 这个 hooks，由于被裁员之后的摆烂(一个月) + 下班回家高强度 <del>LOL</del> 和 <del>Csgo</del>，我差点忘了这个 hooks 的用途，今天来复习一下</p><h2 id="React-memo"><a href="#React-memo" class="headerlink" title="React.memo()"></a>React.memo()</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>React 中当组件的 props 或 state 变化时，会重新渲染视图，实际开发会遇到不必要的渲染场景。看个例子：</p><p>子组件：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ChildComp</span>: <span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;子组件render&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>====子组件===<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">ChildComp</span>;</span><br></pre></td></tr></table></figure><p>父组件:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ChildComp</span> <span class="keyword">from</span> <span class="string">&quot;./components/child&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App</span>: <span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;increment&#125;</span>&gt;</span>点击次数：&#123;count&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ChildComp</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>当我们点击父组件的按钮时，会触发父组件的 setState 从而导致父组件重新渲染，但此时子组件并没有任何变化，但是依然能在控制台中看到子组件被重新渲染的信息</p><p><img src="https://s2.loli.net/2022/12/03/pfJL8HMTk6ys7de.jpg" alt="为加memo时，子组件被重新渲染.jpg"></p><p><font color="red" size="3">我们期待的结果：子组件的 props 和 state 没有变化时，即便父组件渲染，也不要渲染子组件。</font></p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p><strong>修改子组件，用 React.memo() 包一层</strong>。</p><p>这种写法是 React 的高阶组件写法，将组件作为函数(memo)的参数，函数的返回值(ChildComp)是一个新的组件。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; memo &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">memo</span>(<span class="title class_">ChildComp</span>);</span><br></pre></td></tr></table></figure><h2 id="React-useCallback"><a href="#React-useCallback" class="headerlink" title="React.useCallback()"></a>React.useCallback()</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>上面的例子中，父组件只是简单调用子组件，并未给子组件传递任何属性。<br>当一个父组件给子组件传递属性时：</p><p>子组件：（子组件仍然用 React.memo() 包裹一层）</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; memo &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IProps</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">onClick</span>: <span class="function">(<span class="params">val: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ChildComp</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">IProps</span>&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; name, onClick &#125; = props;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`子组件render, 这是传递过来的参数：<span class="subst">$&#123;name&#125;</span> `</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      ====子组件===</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> onClick(&quot;hello&quot;)&#125;&gt;改变 name 值<span class="tag">&lt;/<span class="name">button</span>&gt;</span>;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">memo</span>(<span class="title class_">ChildComp</span>);</span><br></pre></td></tr></table></figure><p>父组件：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ChildComp</span> <span class="keyword">from</span> <span class="string">&quot;./components/child&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App</span>: <span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [name, setName] = <span class="title function_">useState</span>(<span class="string">&quot;hi~&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">changeName</span> = (<span class="params">newName: <span class="built_in">string</span></span>) =&gt; <span class="title function_">setName</span>(newName);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;increment&#125;</span>&gt;</span>点击次数：&#123;count&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ChildComp</span> <span class="attr">name</span>=<span class="string">&#123;name&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;changeName&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>当我们点击父组件的按钮时，我们仍然可以看到子组件再不停的渲染</p><p><img src="https://s2.loli.net/2022/12/03/3H5wlRNvaTxPnd8.jpg" alt="QQ截图20221203222017.jpg"></p><h3 id="分析下原因"><a href="#分析下原因" class="headerlink" title="分析下原因"></a>分析下原因</h3><ul><li>我们点击父组件按钮，改变了父组件中 count 变量值（父组件的 state 值），进而导致父组件重新渲染</li><li>父组件重新渲染时，会重新创建 changeName 函数，即传给子组件的 onClick 属性发生了变化，导致子组件渲染</li></ul><p>所以还是由于子组件的 props 改变了，导致子组件渲染了</p><p>（可我们只是点击了父组件的按钮，并未对子组件做任何操作，压根就不希望子组件的 props 有变化……）</p><h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><p><strong>修改父组件的 changeName 方法，用 useCallback 钩子函数包裹一层</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useCallback &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> changeName = <span class="title function_">useCallback</span>(<span class="function">(<span class="params">newName: <span class="built_in">string</span></span>) =&gt;</span> <span class="title function_">setName</span>(newName), []);</span><br></pre></td></tr></table></figure><p>原因：useCallback() 起到了缓存的作用，即便父组件渲染了，useCallback() 包裹的函数也不会重新生成，会返回上一次的函数引用</p><h2 id="React-useMemo"><a href="#React-useMemo" class="headerlink" title="React.useMemo()"></a>React.useMemo()</h2><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><p>前面父组件调用子组件时传递的 name 属性是个字符串，如果换成传递对象会怎样?????</p><p>父组件</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useCallback, useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ChildComp</span> <span class="keyword">from</span> <span class="string">&quot;./components/child&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App</span>: <span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [name, setName] = <span class="title function_">useState</span>(<span class="string">&quot;hi~&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> [age] = <span class="title function_">useState</span>(<span class="number">20</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> changeName = <span class="title function_">useCallback</span>(<span class="function">(<span class="params">newName: <span class="built_in">string</span></span>) =&gt;</span> <span class="title function_">setName</span>(newName), []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> info = &#123; name, age &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;increment&#125;</span>&gt;</span>点击次数：&#123;count&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ChildComp</span> <span class="attr">info</span>=<span class="string">&#123;info&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;changeName&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>子组件</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; memo &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IInfo</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IProps</span> &#123;</span><br><span class="line">  <span class="attr">info</span>: <span class="title class_">IInfo</span>;</span><br><span class="line">  <span class="attr">onClick</span>: <span class="function">(<span class="params">val: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ChildComp</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">IProps</span>&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; info, onClick &#125; = props;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`子组件render, 这是传递过来的参数：<span class="subst">$&#123;info.name&#125;</span>  <span class="subst">$&#123;info.age&#125;</span> `</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      ====子组件===</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> onClick(&quot;hello&quot;)&#125;&gt;改变 name 值<span class="tag">&lt;/<span class="name">button</span>&gt;</span>;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">memo</span>(<span class="title class_">ChildComp</span>);</span><br></pre></td></tr></table></figure><p>当我们点击父组件的按钮时，我们仍然可以看到子组件再不停的渲染</p><p><img src="https://s2.loli.net/2022/12/03/Qb45AThBmP3lEIr.jpg" alt="QQ截图20221203223252.jpg"></p><p>分析原因跟调用函数是一样的：</p><ul><li>点击父组件按钮，触发父组件重新渲染；</li><li>父组件渲染，const info = { name, age } 一行会重新生成一个新对象(地址不一样)，导致传递给子组件的 info 属性值变化，进而导致子组件重新渲染。</li></ul><h3 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h3><p>使用 useMemo 对对象属性包一层<br>useMemo 有两个参数：</p><ul><li>第一个参数是个函数，返回的对象指向同一个引用，不会创建新对象；</li><li>第二个参数是个数组，只有数组中的变量改变时，第一个参数的函数才会返回一个新的对象。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useMemo &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> info = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> (&#123; name, age &#125;), [name, age]);</span><br></pre></td></tr></table></figure><p>再次点击父组件按钮，控制台中不再打印子组件被渲染的信息了</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>屏蔽不想搜索到结果的来源</title>
      <link href="/2022/12/01/%E5%B1%8F%E8%94%BD%E4%B8%8D%E6%83%B3%E6%90%9C%E7%B4%A2%E5%88%B0%E7%BB%93%E6%9E%9C%E7%9A%84%E6%9D%A5%E6%BA%90/"/>
      <url>/2022/12/01/%E5%B1%8F%E8%94%BD%E4%B8%8D%E6%83%B3%E6%90%9C%E7%B4%A2%E5%88%B0%E7%BB%93%E6%9E%9C%E7%9A%84%E6%9D%A5%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h2 id="正常情况下搜索是这样的"><a href="#正常情况下搜索是这样的" class="headerlink" title="正常情况下搜索是这样的"></a>正常情况下搜索是这样的</h2><p><img src="https://s2.loli.net/2022/12/01/hKt2EJ7SYOaAILe.jpg" alt="未加 -csdn 之前.jpg"></p><font size="3">看到了熟悉的 CSDN、慕课(广告)、简书之类的搜索结果，但这并不是我们想要的，因为有的论坛推荐的答案很不靠谱，所以我们可以在搜索的内容后加上 -"我们不想获得结果的来源" 即可屏蔽掉，如下：<font><p><img src="https://s2.loli.net/2022/12/01/1CjLnBe7EpuJylv.jpg" alt="加上 -csdn 之后.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
